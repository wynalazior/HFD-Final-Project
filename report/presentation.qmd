---
title: "HFD Final Project – Group 1"
subtitle: "Opening Range Breakout Strategy and Z Trend Strategy for SP & NQ Futures"
author: "Krzysztof Nalazek, Shah"
date: "January 2026"
format:
  revealjs:
    slide-number: true
    chalkboard: false
    theme: [default, custom.scss]
    transition: slide
    background-transition: fade
    scrollable: false
    smaller: true
    fig-width: 8
    fig-height: 3.5
    fig-align: center
    incremental: false
    code-fold: false
    code-overflow: wrap
execute:
  echo: false
  warning: false
  message: false
---

## Project Setup

:::: {.columns}
::: {.column width="50%"}
**Data Specifications:**

- **Assets:** S&P 500 (SP) & NASDAQ (NQ)  
- **Frequency:** 1-minute bars
- **Period:** 2023 Q1 – 2025 Q2
- **Trading:** Separate signals, portfolio aggregation
:::

::: {.column width="50%"}
**Trading Constraints (both):**

- **Excluded windows:** 9:31–9:40, 15:51–16:00
- **No trading:** 9:31–9:55 (volatility buffer)
- **Forced flat:** 15:40 onwards
- **No overnight positions**
:::
::::

---

## Strategy Overview

:::: {.columns}
::: {.column width="50%"}
### Strategy 1: Opening Range Breakout

**Key Features:**

- Opening range: 09:41–09:55
- Breakout entry with ATR buffer
- Mean-reversion exits
- Low turnover design
:::

::: {.column width="50%"}
### Strategy 2: Z Guided Trend

**Key Features:**

- Trend-following entries (SMA vs SMA_slow level + slope gate)
- z-score entry with z-momentum confirmation (z accelerating into entry)
- Hard constraints: no-trade window, no new entries after 14:30, forced flat from 15:40
- Risk controls: z stop-loss + extreme z stop, cooldown after exits (reduces churn)
:::
<br>
::::

---

```{python}
#| include: false

# Setup: Load libraries and data
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

REPO_ROOT = Path("..")

# Load ORB results
orb_summary_path = REPO_ROOT / "Testing" / "outputs_orb_final" / "orb_final_summary.csv"
orb = pd.read_csv(orb_summary_path)
```

## Strategy 1: Opening Range Breakout (ORB)

**Core Algorithm:**

1. **Opening Range Definition** (09:41–09:55)
   - Calculate High/Low during opening period
   - Forms baseline for breakout detection

2. **Entry Logic** (after 09:55)
   - **Long**: Price > Range_High + (ATR × Multiplier)
   - **Short**: Price < Range_Low - (ATR × Multiplier)
   
3. **Exit Logic**
   - Mean reversion: Exit when price returns inside range
   - Forced flat at 15:40 (no overnight risk)

4. **Risk Controls**
   - One entry per day (prevents overtrading)
   - Volatility-adjusted thresholds (ATR)
   - Transaction cost awareness

## Strategy 02 : Z Guided Trend

**Core Algorithm:**

1. **Trend Definition**
   - Fast SMA for level
   - Slow SMA for intraday trend
   - Trend confirmed by slow SMA slope

2. **Entry and Exit Logic**
   - **Long:** Trend up + price rising + z-score increasing
   - **Short:** Trend down + price falling + z-score decreasing
   - Stop-loss when z moves against position
   - Exit if trend reverses
   - Exit at extreme z-score levels
   - Forced flat at 15:40 (no overnight)

3. **Risk Controls**
   - No trading during 09:31–09:55
   - No new entries after 14:30
   - Cooldown period after exits
   - Transaction costs included in P&L


---


## ORB: Parameter Optimization

::: {.columns}
::: {.column width="50%"}
**3-Way Data Split:**

- **Training** (4 qtrs): 2023_Q1, Q3, 2024_Q2, Q4
- **Validation** (2 qtrs): 2023_Q4, 2025_Q1  
- **Test** (1 qtr): 2025_Q2

**Grid Search:**

- **ATR Window**: [15, 30, 60] minutes
- **ATR Multiplier**: [0.0, 0.05, 0.10, 0.15, 0.20]
- **Selection**: Based on VALIDATION performance

**Optimal Parameters:**

```{python}
#| echo: true
# Best parameters (selected on validation)
print("SP: ATR_window=15, ATR_mult=0.0")
print("NQ: ATR_window=30, ATR_mult=0.2")
```
:::

::: {.column width="50%"}
**STAT Metric:**

$$\text{STAT} = (\text{Sharpe}_{\text{net}} - 0.5) \times \ln(|\text{Net PnL}/1000|)$$

- Penalizes low Sharpe ratios
- Rewards larger absolute PnL
- Balances risk-adjusted and absolute returns

**Methodology:**

1. Evaluate all combinations on TRAIN
2. Select best based on VALIDATION  
3. Final evaluation on TEST (unseen)
:::
:::

---

## Z Guided Trend: Parameter Optimization

::: {.columns}
::: {.column width="50%"}
**Train/Val/Test Split:**

- **Training** (5 qtrs): 2023_Q1, Q3, Q4, 2024_Q4, 2025_Q1
- **Validation** (1 qtr): 2024_Q2  
- **Test** (1 qtr): 2025_Q2 (completely unseen)

**Grid Search:**

- **SMA Window**: [240, 360, 480] minutes  
- **Slow Multiplier**: [3, 4]  
- **Slope Lookback (m)**: [5, 10]  
- **Z Entry Threshold**: [1.4, 1.6, 1.8, 2.0]  
- **Z Stop Threshold**: [3.5, 4.0, 4.5]  
- **Z Stop-Loss (SL) Threshold**: [1.0, 1.5, 2.0]  
- **Z Momentum Threshold**: [0.05, 0.10, 0.20, 0.30]  
- **Cooldown**: [5, 10]  
- **Selection**: Based on VALIDATION performance


:::

::: {.column width="50%"}
**Optimization Objective:**

- We select parameters that maximize Net P&L (transaction costs included).
- This penalizes over-trading automatically via per-trade costs.
- Balances risk-adjusted and absolute returns

**Methodology:**

1. Evaluate all combinations on TRAIN.
2. Use same quarter combination on next year. (Seasonality)
3. Final evaluation on TEST

**Optimal Parameters:**

```{python}
#| echo: false
import pandas as pd
from pathlib import Path

summary = pd.read_csv(Path("../Testing/outputs_strategy02") / "strategy02_summary.csv")

q = "data1_2023_Q4"

best = summary[summary["quarter"] == q].sort_values(["asset"])

for _, r in best.iterrows():
    print(
        f"{r['asset']}: SMA_win={int(r['SMA_win'])}, slow_mult={int(r['slow_mult'])}, slope_m={int(r['slope_m'])}, "
        f"z_entry={r['z_entry']}, z_stop={r['z_stop']}, z_sl={r['z_sl']}, z_mom={r['z_mom']}, cooldown={int(r['cooldown'])}"
    )

```
:::
:::

---

## ORB: Train/Validation/Test Performance

```{python}
#| fig-width: 9
#| fig-height: 4

import matplotlib.pyplot as plt
from matplotlib.image import imread

# Load and display the train/val/test comparison
img_path = REPO_ROOT / "Testing" / "outputs_orb_final" / "train_val_test.png"
if img_path.exists():
    img = imread(img_path)
    fig, ax = plt.subplots(figsize=(9, 4))
    ax.imshow(img)
    ax.axis('off')
    plt.tight_layout()
    plt.show()
else:
    print("Train/Val/Test visualization not found")
```

**Key Observations:**

- Parameters selected based on VALIDATION performance (not training)
- TEST quarter (2025_Q2) is completely unseen during optimization
- Performance degradation from train → validation → test expected, but not reported

---

## Z Guided Trend: Train/Validation/Test Performance

```{python}
#| fig-width: 9
#| fig-height: 4

import matplotlib.pyplot as plt
from matplotlib.image import imread

# Load and display the train/val/test comparison
img_path = REPO_ROOT / "Testing" / "outputs_strategy02" / "train_val_test.png"
if img_path.exists():
    img = imread(img_path)
    fig, ax = plt.subplots(figsize=(9, 4))
    ax.imshow(img)
    ax.axis('off')
    plt.tight_layout()
    plt.show()
else:
    print("Train/Val/Test visualization not found")
```

**Key Observations:**

- Parameters selected based on TRAINING performance.
- TEST quarter (2025_Q2) is completely unseen during optimization.
- Performance degradation in PnL form, with modest risk adjusted resturns.

---

## ORB: Key Performance Metrics

```{python}
import matplotlib.pyplot as plt
import matplotlib.dates as mdates

# Load data
out_dir = REPO_ROOT / "Testing" / "outputs_orb_final"
daily_files = sorted(out_dir.glob("*_portfolio_daily.csv"))

daily_all = []
for fp in daily_files:
    d = pd.read_csv(fp)
    d["date"] = pd.to_datetime(d["date"])
    daily_all.append(d)

daily_all = pd.concat(daily_all).sort_values("date")
daily_all["cum_gross"] = daily_all["gross_pnl"].cumsum()
daily_all["cum_net"] = daily_all["net_pnl"].cumsum()

# Calculate metrics
total_net_pnl = daily_all["net_pnl"].sum()
sharpe = daily_all["net_pnl"].mean() / daily_all["net_pnl"].std() * np.sqrt(252)
cum_pnl = daily_all["cum_net"]
max_dd = (cum_pnl - cum_pnl.cummax()).min()
calmar = (daily_all["net_pnl"].mean() * 252) / abs(max_dd) if max_dd != 0 else np.nan
win_rate = (daily_all["net_pnl"] > 0).sum() / len(daily_all) * 100

# Display metrics
metrics_df = pd.DataFrame({
    'Metric': ['Total Net PnL', 'Annualized Sharpe', 'Annualized Calmar', 
               'Max Drawdown', 'Win Rate', 'Total Days'],
    'Value': [f'${total_net_pnl:,.2f}', f'{sharpe:.3f}', f'{calmar:.3f}',
              f'${max_dd:,.2f}', f'{win_rate:.1f}%', f'{len(daily_all)}']
})
metrics_df
```

---

## Z Trend: Key Performance Metrics
```{python}
import numpy as np
import pandas as pd
from pathlib import Path

# Quarto runs from ./report, but outputs_strategy02 is at repo root
OUT_DIR = Path("../Testing/outputs_strategy02")

daily_files = sorted(OUT_DIR.glob("*_PORTFOLIO_daily.csv"))
if not daily_files:
    raise ValueError(f"No *_PORTFOLIO_daily.csv found in {OUT_DIR}. Found: {[p.name for p in OUT_DIR.glob('*.csv')]}")
daily_all = []
for fp in daily_files:
    d = pd.read_csv(fp)
    d["date"] = pd.to_datetime(d["date"])
    daily_all.append(d[["date","gross_pnl","net_pnl","trades"]])

daily_all = pd.concat(daily_all, ignore_index=True).sort_values("date")
daily_all["cum_gross"] = daily_all["gross_pnl"].cumsum()
daily_all["cum_net"]   = daily_all["net_pnl"].cumsum()

total_net_pnl = float(daily_all["net_pnl"].sum())
sd = daily_all["net_pnl"].std(ddof=1)
sharpe = float(daily_all["net_pnl"].mean() / sd * np.sqrt(252)) if sd and np.isfinite(sd) else np.nan

cum_pnl = daily_all["cum_net"]
max_dd  = float((cum_pnl - cum_pnl.cummax()).min())
calmar  = float((daily_all["net_pnl"].mean() * 252) / abs(max_dd)) if max_dd and np.isfinite(max_dd) and max_dd != 0 else np.nan

win_rate = float((daily_all["net_pnl"] > 0).mean() * 100)
total_days = int(len(daily_all))

pd.DataFrame({
    "Metric": ["Total Net PnL", "Annualized Sharpe", "Annualized Calmar", "Max Drawdown", "Win Rate", "Total Days"],
    "Value":  [f"${total_net_pnl:,.2f}", f"{sharpe:.3f}", f"{calmar:.3f}", f"${max_dd:,.2f}", f"{win_rate:.1f}%", f"{total_days}"]
})

```


## ORB: Portfolio Performance

```{python}
#| fig-width: 9
#| fig-height: 6
from pathlib import Path
from IPython.display import Image, display

REPO_ROOT = Path.cwd().parent
img_path = REPO_ROOT / "Testing" / "outputs_orb_final" / "portfolio_performance.png"

if img_path.exists():
    display(Image(filename=str(img_path)))
else:
    print(f"Image not found: {img_path}")
```

---

## Z Guided Trend : Portfolio Performance
```{python}
#| fig-width: 9
#| fig-height: 6
from pathlib import Path
from IPython.display import Image, display

REPO_ROOT = Path.cwd().parent
img_path = REPO_ROOT / "Testing" / "outputs_strategy02" / "portfolio_performance.png"

if img_path.exists():
    display(Image(filename=str(img_path)))
else:
    print(f"Image not found: {img_path}")
```

---

## ORB: Quarterly Performance Breakdown

```{python}
#| fig-width: 9
#| fig-height: 5

orb_port = orb[orb["asset"]=="PORTFOLIO"].copy()

fig, axes = plt.subplots(2, 2, figsize=(9, 5))

# 1. Net PnL by Quarter
ax1 = axes[0, 0]
quarters = orb_port["quarter"].tolist()
net_pnls = orb_port["net_cumPnL"].tolist()
colors_bars = ['green' if x >= 0 else 'red' for x in net_pnls]
ax1.bar(range(len(quarters)), net_pnls, color=colors_bars, alpha=0.7)
ax1.set_xticks(range(len(quarters)))
ax1.set_xticklabels(quarters, rotation=45, ha='right', fontsize=8)
ax1.axhline(0, color='black', linestyle='-', linewidth=0.8)
ax1.set_title("Net PnL by Quarter", fontsize=10, fontweight='bold')
ax1.set_ylabel("Net PnL ($)", fontsize=9)
ax1.grid(True, alpha=0.3, axis='y')

# 2. Sharpe Ratio by Quarter
ax2 = axes[0, 1]
sharpes = orb_port["netSR"].tolist()
ax2.bar(range(len(quarters)), sharpes, color='steelblue', alpha=0.7)
ax2.set_xticks(range(len(quarters)))
ax2.set_xticklabels(quarters, rotation=45, ha='right', fontsize=8)
ax2.axhline(0, color='black', linestyle='-', linewidth=0.8)
ax2.set_title("Sharpe Ratio by Quarter", fontsize=10, fontweight='bold')
ax2.set_ylabel("Sharpe Ratio", fontsize=9)
ax2.grid(True, alpha=0.3, axis='y')

# 3. Calmar Ratio by Quarter  
ax3 = axes[1, 0]
calmars = orb_port["netCR"].tolist()
ax3.bar(range(len(quarters)), calmars, color='darkorange', alpha=0.7)
ax3.set_xticks(range(len(quarters)))
ax3.set_xticklabels(quarters, rotation=45, ha='right', fontsize=8)
ax3.axhline(0, color='black', linestyle='-', linewidth=0.8)
ax3.set_title("Calmar Ratio by Quarter", fontsize=10, fontweight='bold')
ax3.set_ylabel("Calmar Ratio", fontsize=9)
ax3.grid(True, alpha=0.3, axis='y')

# 4. Average Trades per Day
ax4 = axes[1, 1]
avg_trades = orb_port["av.ntrades"].tolist()
ax4.bar(range(len(quarters)), avg_trades, color='purple', alpha=0.7)
ax4.set_xticks(range(len(quarters)))
ax4.set_xticklabels(quarters, rotation=45, ha='right', fontsize=8)
ax4.set_title("Average Trades per Day by Quarter", fontsize=10, fontweight='bold')
ax4.set_ylabel("Avg Trades/Day", fontsize=9)
ax4.grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.show()
```

---


## Z Guided Trend : Quarterly Performance Breakdown
```{python}
#| fig-width: 9
#| fig-height: 5
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

# ---- load your Z Guided TrendB perf table (PORTFOLIO rows) ----
BASE_DIR = Path.cwd()                  # report/
OUT_DIR  = BASE_DIR.parent / "Testing" / "outputs_strategy02"
perf = pd.read_csv(OUT_DIR / "strategy02_perf.csv")

s2b_port = perf[perf["asset"] == "PORTFOLIO"].copy()
s2b_port = s2b_port.sort_values("quarter")

fig, axes = plt.subplots(2, 2, figsize=(9, 5))

quarters = s2b_port["quarter"].tolist()

# 1. Net PnL by Quarter
ax1 = axes[0, 0]
net_pnls = s2b_port["net_cumPnL"].tolist()
colors_bars = ["green" if x >= 0 else "red" for x in net_pnls]
ax1.bar(range(len(quarters)), net_pnls, color=colors_bars, alpha=0.7)
ax1.set_xticks(range(len(quarters)))
ax1.set_xticklabels(quarters, rotation=45, ha="right", fontsize=8)
ax1.axhline(0, color="black", linestyle="-", linewidth=0.8)
ax1.set_title("Net PnL by Quarter", fontsize=10, fontweight="bold")
ax1.set_ylabel("Net PnL ($)", fontsize=9)
ax1.grid(True, alpha=0.3, axis="y")

# 2. Sharpe Ratio by Quarter
ax2 = axes[0, 1]
sharpes = s2b_port["netSR"].tolist()
ax2.bar(range(len(quarters)), sharpes, color='steelblue', alpha=0.7)
ax2.set_xticks(range(len(quarters)))
ax2.set_xticklabels(quarters, rotation=45, ha="right", fontsize=8)
ax2.axhline(0, color="black", linestyle="-", linewidth=0.8)
ax2.set_title("Sharpe Ratio by Quarter", fontsize=10, fontweight="bold")
ax2.set_ylabel("Sharpe Ratio", fontsize=9)
ax2.grid(True, alpha=0.3, axis="y")

# 3. Calmar Ratio by Quarter
ax3 = axes[1, 0]
calmars = s2b_port["netCR"].tolist()
ax3.bar(range(len(quarters)), calmars, color='darkorange', alpha=0.7)
ax3.set_xticks(range(len(quarters)))
ax3.set_xticklabels(quarters, rotation=45, ha="right", fontsize=8)
ax3.axhline(0, color="black", linestyle="-", linewidth=0.8)
ax3.set_title("Calmar Ratio by Quarter", fontsize=10, fontweight="bold")
ax3.set_ylabel("Calmar Ratio", fontsize=9)
ax3.grid(True, alpha=0.3, axis="y")

# 4. Average Trades per Day
ax4 = axes[1, 1]
avg_trades = s2b_port["av.ntrades"].tolist()
ax4.bar(range(len(quarters)), avg_trades, color='purple', alpha=0.7)
ax4.set_xticks(range(len(quarters)))
ax4.set_xticklabels(quarters, rotation=45, ha="right", fontsize=8)
ax4.set_title("Average Trades per Day by Quarter", fontsize=10, fontweight="bold")
ax4.set_ylabel("Avg Trades/Day", fontsize=9)
ax4.grid(True, alpha=0.3, axis="y")

plt.tight_layout()
plt.show()

```

---


## ORB: Per-Asset Results

```{python}
orb_assets = orb[orb["asset"].isin(["SP","NQ"])].copy()

# Format for better readability
display_cols = ['quarter', 'asset', 'atr_window', 'atr_mult', 
                'netSR', 'netCR', 'net_cumPnL', 'av.ntrades', 'stat']
orb_display = orb_assets[display_cols].copy()
orb_display['net_cumPnL'] = orb_display['net_cumPnL'].apply(lambda x: f'${x:,.0f}')
orb_display['netSR'] = orb_display['netSR'].apply(lambda x: f'{x:.3f}')
orb_display['netCR'] = orb_display['netCR'].apply(lambda x: f'{x:.3f}')
orb_display['av.ntrades'] = orb_display['av.ntrades'].apply(lambda x: f'{x:.1f}')
orb_display['stat'] = orb_display['stat'].apply(lambda x: f'{x:.4f}')
orb_display
```

---


## Z Guided Trend: Per-Asset Results

```{python}
import pandas as pd
from pathlib import Path

# ---- load your Z Guided TrendB perf table ----
BASE_DIR = Path.cwd()                  # report/
OUT_DIR  = BASE_DIR.parent / "Testing" / "outputs_strategy02"
perf = pd.read_csv(OUT_DIR / "strategy02_perf.csv")

s2b_assets = perf[perf["asset"].isin(["SP","NQ"])].copy().sort_values(["quarter","asset"])

# Columns you actually have (no atr_window/atr_mult/stat)
display_cols = ["quarter", "asset", "netSR", "netCR", "net_cumPnL", "av.ntrades"]
s2b_display = s2b_assets[display_cols].copy()

# Format like your friend's table
s2b_display["net_cumPnL"]  = s2b_display["net_cumPnL"].apply(lambda x: f"${x:,.0f}")
s2b_display["netSR"]       = s2b_display["netSR"].apply(lambda x: f"{x:.3f}")
s2b_display["netCR"]       = s2b_display["netCR"].apply(lambda x: f"{x:.3f}")
s2b_display["av.ntrades"]  = s2b_display["av.ntrades"].apply(lambda x: f"{x:.1f}")

s2b_display

```

---
## ORB: Strategy Summary

::: {.columns}
::: {.column width="50%"}
**Strengths:**

- Consistent positive returns across most quarters
- Low turnover (controlled transaction costs)
- Clear entry/exit rules
- Adapts to volatility via ATR

**Key Observations:**

- Strategy performs well in trending markets
- ATR filter effectively reduces false breakouts
- Mean-reversion exit manages risk
:::

::: {.column width="50%"}
**Risk Management:**

- No overnight positions (flat at 15:40)
- One entry per day (prevents overtrading)
- Volatility-adjusted thresholds
- Excludes unreliable time windows

**Overall Portfolio Performance:**

```{python}
#| echo: true
overall_stat = orb_port["stat"].sum()
overall_pnl = orb_port["net_cumPnL"].sum()
overall_sharpe = orb_port["netSR"].mean()
print(f"Total Net PnL: ${overall_pnl:,.2f}")
print(f"Total STAT Score: {overall_stat:.4f}")
print(f"Avg Net Sharpe: {overall_sharpe:.3f}")
```
:::
:::

---

## Z Guided Trend: Strategy Summary

::: {.columns}
::: {.column width="50%"}
**Strengths:**

- Trend-aligned entries via fast/slow SMA filter
- Uses z-momentum confirmation to reduce early/late fades
- Intraday-only design (no overnight exposure)
- Works on both SP and NQ with the same logic

**Key Observations:**

- Best performance tends to occur in sustained intraday trends
- Z-momentum filter helps avoid entries on flattening/extreme z moves
- Cooldown reduces rapid flip-flopping after exits
:::

::: {.column width="50%"}
**Risk Management:**

- No trading during 09:31–09:55 (volatility buffer)
- No new entries after 14:30
- Forced flat from 15:40 onwards
- Stop-loss in z-space + extreme z exits
- Transaction costs included in net P&L

**Overall Portfolio Performance:**

```{python}
#| echo: true
import pandas as pd
from pathlib import Path

BASE_DIR = Path.cwd()
OUT_DIR  = BASE_DIR.parent / "Testing" / "outputs_strategy02"
perf = pd.read_csv(OUT_DIR / "strategy02_perf.csv")

port = perf[perf["asset"]=="PORTFOLIO"]
overall_pnl = port['net_cumPnL'].sum()
overall_sharpe = port['netSR'].mean()
# Calculate STAT for Strategy 2
overall_stat = sum([(sr - 0.5) * np.log(abs(pnl/1000)) if pnl != 0 and np.isfinite(sr) else 0 
                    for sr, pnl in zip(port['netSR'], port['net_cumPnL'])])
print(f"Total Net PnL: ${overall_pnl:,.2f}")
print(f"Total STAT Score: {overall_stat:.4f}")
print(f"Avg Net Sharpe: {overall_sharpe:.3f}")
```
:::
:::

---

## Strategy Comparison: ORB vs Z Guided Trend

```{python}
#| fig-width: 10
#| fig-height: 5

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

# Load both strategies' performance
s1_perf = pd.read_csv(REPO_ROOT / "Testing" / "outputs_orb_final" / "orb_final_summary.csv")
s2_perf = pd.read_csv(REPO_ROOT / "Testing" / "outputs_strategy02" / "strategy02_perf.csv")

# Filter for PORTFOLIO only
s1_port = s1_perf[s1_perf["asset"] == "PORTFOLIO"].copy().sort_values("quarter")
s2_port = s2_perf[s2_perf["asset"] == "PORTFOLIO"].copy().sort_values("quarter")

# Create comparison
quarters_short = s2_port["quarter"].str.replace("data1_", "").tolist()
x = np.arange(len(quarters_short))
width = 0.35

fig, axes = plt.subplots(2, 2, figsize=(10, 5))

# 1. Net PnL Comparison
ax1 = axes[0, 0]
bars1 = ax1.bar(x - width/2, s2_port["net_cumPnL"], width, label='Z Guided Trend', color='darkblue', alpha=0.7)
bars2 = ax1.bar(x + width/2, s1_port["net_cumPnL"], width, label='ORB', color='darkred', alpha=0.7)
ax1.set_xlabel('Quarter', fontweight='bold', fontsize=9)
ax1.set_ylabel('Net PnL ($)', fontweight='bold', fontsize=9)
ax1.set_title('Net PnL Comparison by Quarter', fontsize=10, fontweight='bold')
ax1.set_xticks(x)
ax1.set_xticklabels(quarters_short, rotation=45, ha='right', fontsize=7)
ax1.legend(fontsize=8)
ax1.grid(True, alpha=0.3, axis='y')
ax1.axhline(0, color='black', linestyle='-', linewidth=0.8)

# 2. Sharpe Ratio Comparison
ax2 = axes[0, 1]
ax2.bar(x - width/2, s2_port["netSR"], width, label='Z Guided Trend', color='steelblue', alpha=0.7)
ax2.bar(x + width/2, s1_port["netSR"], width, label='ORB', color='coral', alpha=0.7)
ax2.set_xlabel('Quarter', fontweight='bold', fontsize=9)
ax2.set_ylabel('Sharpe Ratio', fontweight='bold', fontsize=9)
ax2.set_title('Sharpe Ratio Comparison by Quarter', fontsize=10, fontweight='bold')
ax2.set_xticks(x)
ax2.set_xticklabels(quarters_short, rotation=45, ha='right', fontsize=7)
ax2.legend(fontsize=8)
ax2.grid(True, alpha=0.3, axis='y')
ax2.axhline(0, color='black', linestyle='-', linewidth=0.8)

# 3. Cumulative PnL Over Time
ax3 = axes[1, 0]
s2_cum = s2_port["net_cumPnL"].cumsum()
s1_cum = s1_port["net_cumPnL"].cumsum()
ax3.plot(quarters_short, s2_cum, marker='o', linewidth=2.5, label='Z Guided Trend', color='darkblue')
ax3.plot(quarters_short, s1_cum, marker='s', linewidth=2.5, label='ORB', color='darkred')
ax3.set_xlabel('Quarter', fontweight='bold', fontsize=9)
ax3.set_ylabel('Cumulative Net PnL ($)', fontweight='bold', fontsize=9)
ax3.set_title('Cumulative Net PnL Comparison', fontsize=10, fontweight='bold')
ax3.set_xticks(range(len(quarters_short)))
ax3.set_xticklabels(quarters_short, rotation=45, ha='right', fontsize=7)
ax3.legend(fontsize=8)
ax3.grid(True, alpha=0.3)
ax3.axhline(0, color='black', linestyle='--', linewidth=0.8)

# 4. Calmar Ratio Comparison
ax4 = axes[1, 1]
ax4.bar(x - width/2, s2_port["netCR"], width, label='Z Guided Trend', color='purple', alpha=0.7)
ax4.bar(x + width/2, s1_port["netCR"], width, label='ORB', color='orange', alpha=0.7)
ax4.set_xlabel('Quarter', fontweight='bold', fontsize=9)
ax4.set_ylabel('Calmar Ratio', fontweight='bold', fontsize=9)
ax4.set_title('Calmar Ratio Comparison by Quarter', fontsize=10, fontweight='bold')
ax4.set_xticks(x)
ax4.set_xticklabels(quarters_short, rotation=45, ha='right', fontsize=7)
ax4.legend(fontsize=8)
ax4.grid(True, alpha=0.3, axis='y')
ax4.axhline(0, color='black', linestyle='-', linewidth=0.8)

plt.suptitle('Portfolio Performance: Z Guided Trend vs ORB', fontsize=12, fontweight='bold', y=0.995)
plt.tight_layout()
plt.show()
```

---

## Final Comparison: Key Metrics

```{python}
import pandas as pd
import numpy as np

# Calculate STAT scores for both strategies
s1_stat_total = s1_port['stat'].sum()
s2_stat_total = sum([(sr - 0.5) * np.log(abs(pnl/1000)) if pnl != 0 and np.isfinite(sr) else 0 
                     for sr, pnl in zip(s2_port['netSR'], s2_port['net_cumPnL'])])

# Calculate summary statistics
comparison_summary = pd.DataFrame({
    'Metric': [
        'Total Net PnL',
        'Total STAT Score',
        'Average Sharpe Ratio',
        'Average Calmar Ratio',
        'Quarters Profitable',
        'Best Quarter PnL',
        'Worst Quarter PnL'
    ],
    'Z Guided Trend': [
        f"${s2_port['net_cumPnL'].sum():,.2f}",
        f"{s2_stat_total:.4f}",
        f"{s2_port['netSR'].mean():.3f}",
        f"{s2_port['netCR'].mean():.3f}",
        f"{(s2_port['net_cumPnL'] > 0).sum()}/{len(s2_port)}",
        f"${s2_port['net_cumPnL'].max():,.2f}",
        f"${s2_port['net_cumPnL'].min():,.2f}"
    ],
    'ORB': [
        f"${s1_port['net_cumPnL'].sum():,.2f}",
        f"{s1_stat_total:.4f}",
        f"{s1_port['netSR'].mean():.3f}",
        f"{s1_port['netCR'].mean():.3f}",
        f"{(s1_port['net_cumPnL'] > 0).sum()}/{len(s1_port)}",
        f"${s1_port['net_cumPnL'].max():,.2f}",
        f"${s1_port['net_cumPnL'].min():,.2f}"
    ]
})

comparison_summary
```

---

## Thank You

Questions?
